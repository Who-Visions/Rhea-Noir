# ralph.toml
# Configuration for the Ralph Orchestrator (Rust)
# https://github.com/mikeyobrien/ralph-orchestrator

[cli]
backend = "claude"  # interactions via Claude CLI, Kiro, Gemini, etc.

[event_loop]
completion_promise = "LOOP_COMPLETE"
max_iterations = 50
starting_event = "task.start"

# Hats (Specialized Personas)
# This is where the Rust implementation shines: Event-Driven Architectures.

[hats.planner]
name = "ðŸ§  Planner"
triggers = ["task.start"]
publishes = ["plan.ready"]
instructions = """
You are the Planner.
1. Read the user request.
2. Create a prioritized task list in @fix_plan.md.
3. Publish 'plan.ready' when done.
"""

[hats.builder]
name = "ðŸ”¨ Builder"
triggers = ["plan.ready", "test.failed"]
publishes = ["build.done"]
instructions = """
You are the Builder.
1. Pick the next item from @fix_plan.md.
2. Implement the code.
3. Publish 'build.done' ONLY when you have written the code.
"""

[hats.verifier]
name = "QC Verifier"
triggers = ["build.done"]
publishes = ["test.passed", "test.failed"]
instructions = """
You are the Verifier.
1. Run the project tests/build.
2. If it fails, publish 'test.failed' with the error log.
3. If it passes, publish 'test.passed'.
"""

[core]
scratchpad = ".agent/scratchpad.md"
guardrails = [
    "Fresh context each iteration",
    "Backpressure is law - tests must pass",
    "Do not assume API availability - check first"
]
